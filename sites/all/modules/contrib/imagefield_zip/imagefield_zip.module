<?php

/**
 * @file
 * Adds in a zip or html5 upload field to the form.
 */

/**
 * Default location of zip upload form.
 */
define('IMAGEFIELD_ZIP_CCK_WIDGET', 0);

if (!function_exists('zip_open')) {
  /**
  * Default mode for the multi upload form.
  */
  define('IMAGEFIELD_ZIP_UPLOAD_MODE', 1);

  /**
  * Default fallback mode for non html 5 browsers.
  */
  define('IMAGEFIELD_ZIP_FALLBACK', 1);
}
else {
  /**
  * Default mode for the multi upload form.
  */
  define('IMAGEFIELD_ZIP_UPLOAD_MODE', 0);

  /**
  * Default fallback mode for non html 5 browsers.
  */
  define('IMAGEFIELD_ZIP_FALLBACK', 0);
}

/**
 * Implementation of hook_menu().
 */
function imagefield_zip_menu() {
  $items = array();

  $items['admin/settings/imagefield-zip'] = array(
    'title' => 'Imagefield Zip Upload',
    'description' => 'Configuration page for Imagefield Zip Upload.',
    'page callback' => 'imagefield_zip_admin_page',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'imagefield_zip.admin.inc',
  );

  // Callback for AHAH zip upload buttons.
  $items['imagefield_zip/ahah/%/%'] = array(
    'page callback' => 'imagefield_zip_js',
    'page arguments' => array(2, 3),
    'access callback' => 'filefield_edit_access',
    'access arguments' => array(2, 3),
    'type' => MENU_CALLBACK,
    'file' => 'imagefield_zip.ahah.inc',
  );
  $items['imagefield_zip/ahah-multigroup/%/%'] = array(
    'page callback' => 'imagefield_zip_multigroup_js',
    'page arguments' => array(2, 3),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'imagefield_zip.ahah.inc',
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function imagefield_zip_perm() {
  return array('access imagefield_zip widget');
}

/**
 * Implementation of hook_form_alter().
 */
function imagefield_zip_form_alter(&$form, &$form_state, $form_id) {
  // Alter node add/edit forms & add in a zip/html5 upload form on imagefields.
  if (   isset($form['type'])
      && isset($form['#node'])
      && $form['type']['#value'] .'_node_form' == $form_id
      && ($type = content_types($form['#node']->type))
      && user_access('access imagefield_zip widget')
        ) {
    // Get any field groups in the form
    $groups = imagefield_zip_get_groups($form);

    // Add in the zip/html5 upload form to the correct form elements.
    $changed = FALSE;
    foreach (_imagefield_zip_fields($type) as $field) {
      $temp = imagefield_zip_add_to_node_form($form, $field['field_name'], $form['#node'], $groups);
      if (!$changed && $temp) {
        $changed = $temp;
      }
    }

    // Add in custom submit handler and after build function call.
    if ($changed) {
      $form['#submit'][] = 'imagefield_zip_page_submit';
      $form['#after_build'][] = '_imagefield_zip_form_after_build';
    }
  }

  // Add form elements to the CCK admin widget configuration page.
  // Make sure form is a filefiled using the imagefield widget.
  if (   !empty($form['basic']['type']['#value'])
      && $form['basic']['type']['#value'] == 'filefield'
      && !empty($form['widget_module']['#value'])
      && $form['widget_module']['#value'] == 'imagefield'
        ) {
    // Call function in imagefield_zip.admin.inc
    module_load_include('inc', 'imagefield_zip', 'imagefield_zip.admin');
    return imagefield_zip_cck_widget_form($form, $form_state, $form_id);
  }
}

/**
 * After_build function to modify CCK fields
 */
function _imagefield_zip_form_after_build(&$form, &$form_state) {
  global $_imagefield_zip;
  // Add in javascript that handles the file form element.
  drupal_add_js(drupal_get_path('module', 'imagefield_zip') . '/imagefield_zip.js');

  $type = content_types($form['#node']->type);
  foreach (_imagefield_zip_fields($type) as $field) {
    $field_name = $field['field_name'];

    // Get the weight of the widget.
    $weight = 0.01;
    $widget_settings = variable_get('imagefield_zip_cck_widget_' . $type['type'] . '_' . $field_name, IMAGEFIELD_ZIP_CCK_WIDGET);
    if ($widget_settings == 2) {
      continue;
    }
    if ($widget_settings == 0) {
      $weight = -0.01;
    }

    $in_a_group = FALSE;
    // Set the weight if in a group.
    if (!isset($form[$field_name]) && !empty($_imagefield_zip['groups'])) {
      foreach ($_imagefield_zip['groups'] as $group_name) {
        if (empty($form[$group_name]) || empty($form[$group_name]['#group_fields'][$field_name]) || !isset($form[$group_name]['#weight']) || empty($form[$group_name . '_zip'])) {
          continue;
        }

        $form[$group_name . '_zip']['#weight'] = $form[$group_name]['#weight'] + $weight;
        $in_a_group = TRUE;

        _imagefield_zip_add_inline_js($group_name);
      }
    }

    // Move zip upload into fieldset if imagefield is in fieldset.
    if (!isset($form[$field_name]) && isset($form[$field_name . '_zip'])) {
      _imagefield_zip_cck_walker($form, $field_name, $form[$field_name . '_zip']);
      unset($form[$field_name .'_zip']);
    }

    // Add field name to js settings for file form element handling.
    if (!$in_a_group) {
      _imagefield_zip_add_inline_js($field_name);
    }
  }

  return $form;
}

/**
 * Add field/group name to js settings array.
 *
 * @param $name
 *   field/group name.
 */
function _imagefield_zip_add_inline_js(&$name) {
  $settings = array(
    'imagefield_zip_names' => array($name),
  );
  drupal_add_js($settings, 'setting');
}

/**
 * Get the fieldgroups attached to a field.
 *
 * @see fieldgroup_form_alter()
 */
function imagefield_zip_get_groups(&$form) {
  // Get groups if available.
  $groups = array();
  if (module_exists('fieldgroup')) {
    // Code below is from fieldgroup_form_alter().
    $group_rows = array();
    $field_rows = array();

    // Prepare data that will make this easier.
    $groups = fieldgroup_groups($form['type']['#value']);
    if (!empty($groups)) {
      foreach ($groups as $name => $more) {
        $group_rows[] = $name;
      }
    }

    if (!empty($form['#field_info'])) {
      $fields = $form['#field_info'];
      foreach ($fields as $name => $more) {
        $field_rows[] = $name;
      }
    }

    // This function doesn't exist in CCK2.
    if (function_exists('fieldgroup_order_fields_groups')) {
      fieldgroup_order_fields_groups($group_rows, $groups, $field_rows);
    }
  }
  return $groups;
}

/**
 * Recursively walk down the $form array looking for the CCK elements to modify
 *
 * @param $array array
 *     the $form array or piece of the form array when called recursively (must be passed by reference)
 * @param $cck_field string
 *    key name to look for.
 * @param $zip_field array
 *    form to insert into the fieldset.
 * @see http://drupal.org/node/726282#comment-2848294
 */
function _imagefield_zip_cck_walker(&$array, &$cck_field, &$zip_field) {
  foreach ($array as $key => &$value) {
    if (is_array($value)) {
      if (isset($value['#type']) && $value['#type'] == 'fieldset') {
        // Call this function again recursively
        _imagefield_zip_cck_walker($value, $cck_field, $zip_field);
        continue;
      }
      if ($key == $cck_field) {
        $array[$cck_field . '_zip'] = $zip_field;
      }
    }
  }
}

/**
 * Stores the image files from ZIP files to the appropriate imagefields.
 *
 * @param $field_name
 *   Field containing the zip upload file input.
 * @param $node_type
 *   name of node type
 * @param $op
 *   what kind of operation; submit or ahah.
 * @return array
 *   array of image file objects.
 */
function imagefield_zip_save_and_extract_upload($field_name, $node_type, $op) {
  // Get the target field from the given input.
  $content_type = content_types($node_type);
  $target_field = str_replace('_zip', '', $field_name);
  if (strpos($target_field, 'group_') === 0) {
    $fields = _imagefield_zip_fields($content_type);
    $groups = fieldgroup_groups($node_type);

    // Find the correct field to add the images to.
    foreach ($fields as $temp_field_name => $field) {
      if (isset($groups[$target_field]['fields'][$temp_field_name])) {
        $target_field = $temp_field_name;
        break;
      }
    }
  }
  // Get the upload mode and the file extensions allowed.
  $upload_mode = variable_get('imagefield_zip_upload_mode_' . $node_type . '_' . $target_field, NULL);
  $formats = $content_type['fields'][$target_field]['widget']['file_extensions'];

  // Get context from $_FILES and create a files array.
  $files_array = imagefield_zip_files_array_extractor($field_name);
  $images = array();
  if (!empty($files_array)) {
    foreach ($files_array as $file_array) {
      $file = imagefield_zip_file_save_upload($field_name, array(), FALSE, FILE_EXISTS_RENAME, $file_array);
      if (!$file) {
        watchdog('imagefield_zip', 'Failed to save uploaded file', array(), WATCHDOG_ERROR);
        continue;
      }

      // Verify & extract files.
      $extracted = array();
      if ($upload_mode == 0) {
        // Zip only.
        if (!imagefield_zip_is_valid_zip($file)) {
          continue;
        }
        $extracted = imagefield_zip_extract($file, $formats);
      }
      elseif ($upload_mode == 1) {
        // Images only.
        if (!imagefield_zip_is_image($file, $formats)) {
          continue;
        }
        $extracted[] = $file;
      }
      elseif ($upload_mode == 2) {
        // Images & zip only.
        if (!imagefield_zip_is_image($file, $formats)) {
          if (!imagefield_zip_is_valid_zip($file)) {
            continue;
          }
          $extracted = imagefield_zip_extract($file, $formats);
        }
        else {
          $extracted[] = $file;
        }
      }

      if (empty($extracted)) {
        watchdog('imagefield_zip', 'No images uploaded.', array(), WATCHDOG_WARNING);
        continue;
      }
      // Add the extracted images to the return array.
      $images = array_merge($images, $extracted);
    }
  }

  // Send error messages back if in ahah mode.
  if (empty($images) && $op == 'ahah') {
    if (empty($files_array)) {
      drupal_set_message(t('No file selected.'), 'warning');
    }
    elseif ($upload_mode == 0) {
      drupal_set_message(t('The file uploaded was not a valid zip file.'), 'warning');
    }
    elseif ($upload_mode == 1) {
      drupal_set_message(t('Only image files in these formats can be uploaded: @formats.', array('@formats' => $formats)), 'warning');
    }
    elseif ($upload_mode == 2) {
      drupal_set_message(t('Only files in these formats can be uploaded: @formats zip.', array('@formats' => $formats)), 'warning');
    }
  }

  return $images;
}

/**
 * Recursively search the array to see if any values in it are not empty.
 *
 * @param $values
 *   array of values to check.
 */
function imagefield_zip_files_array($values) {
  if (is_array($values)) {
    foreach ($values as $key => $value) {
      $test = imagefield_zip_files_array($value);
      if ($test == TRUE) {
        return TRUE;
      }
    }
  }
  elseif (!empty($values)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Stores image files from ZIP files/html5 multi-upload to the appropriate imagefields.
 *
 * @see imagefield_zip_page()
 */
function imagefield_zip_page_submit($form, &$form_state) {
  // Bail out if no images where uploaded.
  if (!imagefield_zip_files_array($_FILES['files']['size'])) {
    return;
  }

  // Get info from the form.
  $type = content_types($form['#node']->type);
  module_load_include('inc', 'content', 'includes/content.node_form');
  global $user;
  $groups = imagefield_zip_get_groups($form);

  // Select the correct fields from the form.
  $out = array();
  foreach (_imagefield_zip_fields($type) as $zip_field) {
    // Get filefield destination.
    $field = content_fields($zip_field['field_name'], $form['#node']->type);
    $dest = filefield_widget_file_path($field);

    // Get group names.
    $group_names = array();
    if (!empty($groups)) {
      foreach ($groups as $group_name => $group) {
        if (!empty($group['fields'][$zip_field['field_name']])) {
          // Code adapted from content_multigroup_add_more().
          if (empty($group['settings']['multigroup']['multiple']) || (isset($group['settings']['multigroup']['multiple']) && $group['settings']['multigroup']['multiple'] != 1)) {
            continue;
          }
          $group_names[] = $group_name;
        }
      }
    }

    // Set & find zip upload field name.
    $field_name = $zip_field['field_name'] . '_zip';
    $group_id = -1;
    $found = FALSE;
    while (!$found) {
      $found = imagefield_zip_array_find_element_by_key($field_name, $form);
      $group_id++;
      if (!$found && !empty($group_names[$group_id])) {
        $field_name = $group_names[$group_id] . '_zip';
      }
      else {
        break;
      }
    }
    if (!$found) {
      continue;
    }

    // Get images from the zip file.
    $images = imagefield_zip_save_and_extract_upload($field_name, $form['#node']->type, 'submit');
    if (empty($images)) {
      continue;
    }

    // Put the file in the new element.
    foreach ($images as $image) {
      if ($file = field_file_save_file($image->filepath, array(), $dest)) {
        foreach ($form_state['values'] as $value_field_name => &$value_field_data) {
          // Skip if not the correct field.
          if ($zip_field['field_name'] != $value_field_name) {
            continue;
          }

          // Find an empty delta and save
          $delta = 0;
          while (!empty($value_field_data[$delta]['fid'])) {
            $delta++;
          }

          // Add info and save into $form_state['values'].
          $file += array(
            'data' => array('title' => FALSE, 'alt' => FALSE),
            'list' => TRUE,
            '_weight' => $delta,
            'uid' => $user->uid,
            '_remove' => 0,
            'upload' => FALSE,
          );
          unset($file['destination']);
          unset($file['source']);
          $value_field_data[$delta] = $file;
        }
      }
    }
  }
}

/**
 * Returns the value of the key in a multidimensional array.
 *
 * http://php.net/array-key-exists#85184
 */
function &imagefield_zip_array_find_element_by_key($key, &$form) {
  if (isset($form[$key])) {
    $ret = &$form[$key];
    return $ret;
  }
  foreach (element_children($form) as $k) {
    if (is_array($form[$k])) {
      $ret = &imagefield_zip_array_find_element_by_key($key, $form[$k]);
      if ($ret) {
        return $ret;
      }
    }
  }
  $x = FALSE;
  return $x;
}

/**
 * Prep to add the zip/html5 file form element to the node form.
 *
 * @param $form
 *   Array. The node form.
 * @param $field_name
 *   String. The name of the field.
 * @param $node
 *   The node object.
 * @param $groups
 *   Array from imagefield_zip_get_groups.
 */
function imagefield_zip_add_to_node_form(&$form, &$field_name, &$node, &$groups) {
  if (empty($form[$field_name])) {
    return FALSE;
  }

  // Get the position of the element; above, below or disabled.
  $weight = 0.01;
  $widget_settings = variable_get('imagefield_zip_cck_widget_' . $node->type . '_' . $field_name, IMAGEFIELD_ZIP_CCK_WIDGET);
  if ($widget_settings == 2) {
    return FALSE;
  }
  if ($widget_settings == 0) {
    $weight = -0.01;
  }

  // Get the other settings for the form element.
  $upload_mode = variable_get('imagefield_zip_upload_mode_' . $node->type . '_' . $field_name, IMAGEFIELD_ZIP_UPLOAD_MODE);
  $fallback_mode = variable_get('imagefield_zip_fallback_' . $node->type . '_' . $field_name, IMAGEFIELD_ZIP_FALLBACK);
  $content_type = content_types($node->type);
  $machine_node_type = $node->type;
  $formats = $content_type['fields'][$field_name]['widget']['file_extensions'];

  // Target filefield could be inside of a field group.
  if (!empty($groups)) {
    foreach ($groups as $group_name => $group) {
      if (empty($group['fields'][$field_name])) {
        continue;
      }

      // Code adapted from content_multigroup_add_more().
      if (empty($group['settings']['multigroup']['multiple']) || (isset($group['settings']['multigroup']['multiple']) && $group['settings']['multigroup']['multiple'] != 1)) {
        continue;
      }

      // Set variables needed.
      $machine_name = $group['group_name'];
      $nice_name = $group['label'];
      $field_or_group = 'group';
      break;
    }
  }

  if (empty($field_or_group)) {
    // Set variables needed.
    $machine_name = $field_name;
    $nice_name = $content_type['fields'][$field_name]['widget']['label'];
    $field_or_group = 'field';
  }

  // Add in the form.
  if (imagefield_zip_build_upload_form($form, $machine_name, $nice_name, $formats, $machine_node_type, $upload_mode, $fallback_mode, $weight, $field_or_group)) {
    if ($field_or_group == 'group') {
      global $_imagefield_zip;
      $_imagefield_zip['groups'][] = $machine_name;
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Adds the zip/html5 file form elements to the node form.
 *
 * @param $form
 *   Array. The node form.
 * @param $machine_name
 *   String. The name of the field/group.
 * @param $nice_name
 *   String. The nice name of the field/group.
 * @param $formats
 *   String of file extensions.
 * @param $machine_node_type
 *   String of the node type.
 * @param $upload_mode
 *   Integer value for what type of files can be uploaded.
 * @param $fallback_mode
 *   What to do if html5 form can not be used.
 * @param $weight
 *   Float value for placing the form element above or below the target.
 * @param $field_or_group
 *   String of either "field" or "group".
 */
function imagefield_zip_build_upload_form(&$form, $machine_name, $nice_name, $formats, $machine_node_type, $upload_mode, $fallback_mode, $weight, $field_or_group) {

  // Set some variables.
  $machine_name_css = str_replace('_', '-', $machine_name);
  $max_filesize = format_size(parse_size(file_upload_max_size()));
  $zip_mime = 'application/zip, application/x-zip, application/x-zip-compressed, application/x-compress, application/x-compressed';

  // The accept attribute only works in chrome; but it's still a nice feature.
  $formats_array = explode(' ', $formats);
  // Special handling for jpg/jpeg.
  $key = array_search('jpg', $formats_array);
  if ($key !== FALSE) {
    unset($formats_array[$key]);
    if (!in_array('jpeg', $formats_array)) {
      $formats_array[$key] = 'jpeg';
    }
  }

  // Handle IE.
  if (imagefield_zip_is_ie()) {
    if ($upload_mode == 2) {
      $upload_mode = 0;
    }
    if ($upload_mode == 1) {
      if ($fallback_mode == 0) {
        $upload_mode = 0;
      }
      if ($fallback_mode == 2) {
        return FALSE;
      }
      if ($fallback_mode == 1) {
        $form[$machine_name .'_zip'] = array(
          '#type' => 'item',
          '#title' => t('Add Multiple Images'),
          '#value' => t('Adding Multiple Images is not yet supported in your browser. Currently this feature requires <a href="http://www.google.com/chrome/">Chrome</a>, <a href="http://www.mozilla.org/en-US/products/download.html">Firefox</a>, or <a href="http://www.apple.com/safari/download/">Safari</a>.'),
          '#prefix' => '<div class="zip-field zip-fallback-message">',
          '#suffix' => '</div>',
        );
        return TRUE;
      }
    }
  }

  // Make sure the form is cached so ahah can work.
  $form['#cache'] = TRUE;

  // Set form defaults.
  $form[$machine_name .'_zip'] = array(
    '#prefix' => '<div class="zip-field">',
    '#suffix' => '</div>',
  );
  $form[$machine_name .'_zip'][$machine_name . '_upload'] = array(
    '#type' => 'file',
    '#size' => 22,
    '#attributes' => array(
      'class' => 'zip-upload',
    ),
  );
  $form[$machine_name .'_zip'][$machine_name . '_button'] = array(
      '#type' => 'submit',
      '#value' => t('Start Upload'),
      // Submit callback for disabled JavaScript. drupal_get_form() might get
      // the form from the cache, so we can't rely on content_form_alter()
      // including this file. Therefore, call a proxy function to do this.
      '#ahah' => array(
        'wrapper' => $machine_name_css .'-items',
        'method' => 'replace',
        'effect' => 'fade',
      ),
      // When JS is disabled, the content_add_more_submit handler will find
      // the relevant field using these entries.
      '#type_name' => $machine_node_type,
      '#suffix' => '<div class="clear-block"><div class="description zip-description">',
      '#attributes' => array(
        'class' => 'zip-submit',
      ),
  );

  // Set attributes based off of settings.
  if ($upload_mode == 0) {
    // Single zip upload.
    $form[$machine_name .'_zip'][$machine_name . '_upload'] += array(
      '#title' => t('Add Zip File Containing Images'),
      '#name' => "files[{$machine_name}_zip]",
    );
    $form[$machine_name .'_zip'][$machine_name . '_upload']['#attributes'] += array(
      'accept' => $zip_mime,
    );
    $form[$machine_name .'_zip'][$machine_name . '_button']['#suffix'] .= t('Add multiple image files to the @name @type @location by selecting a zip file in the dialog box.<br />Allowed image extensions in the zip file: @formats. Maximum zip file size: @max_filesize', array(
        '@max_filesize' => $max_filesize,
        '@formats' => $formats,
        '@name' => $nice_name,
        '@location' => $weight > 0 ? t('above') : t('below'),
        '@type' => $field_or_group,
      )) . '</div></div>';
  }
  elseif ($upload_mode == 1) {
    // Multiple file uploads via html5.
    $form[$machine_name .'_zip'][$machine_name . '_upload'] += array(
      '#title' => t('Add Multiple Images'),
      '#name' => "files[{$machine_name}_zip][]",
    );
    $form[$machine_name .'_zip'][$machine_name . '_upload']['#attributes'] += array(
      'multiple' => 'multiple',
      'accept' => 'image/' . implode(', image/', $formats_array),
    );
    $form[$machine_name .'_zip'][$machine_name . '_button']['#suffix'] .= t('Add multiple image files to the @name @type @location by holding the CTRL key while selecting images in the dialog box<br />Allowed extensions: @formats. Maximum filesize: @max_filesize', array(
        '@max_filesize' => $max_filesize,
        '@formats' => $formats,
        '@name' => $nice_name,
        '@location' => $weight > 0 ? t('above') : t('below'),
        '@type' => $field_or_group,
      )) . '</div></div>';
  }
  elseif ($upload_mode == 2) {
    // Multiple file uploads via html5; with zip support as well.
    $form[$machine_name .'_zip'][$machine_name . '_upload'] += array(
      '#title' => t('Add Multiple Images OR Zip File Containing Images'),
      '#name' => "files[{$machine_name}_zip][]",
    );
    $form[$machine_name .'_zip'][$machine_name . '_upload']['#attributes'] += array(
      'multiple' => 'multiple',
      'accept' => 'image/' . implode(', image/', $formats_array) . ', ' . $zip_mime,
    );
    $form[$machine_name .'_zip'][$machine_name . '_button']['#suffix'] .= t('Add multiple image files to the @name @type @location by holding the CTRL key while selecting images in the dialog box<br />Allowed extensions: @formats with a maximum file size of @max_filesize', array(
        '@max_filesize' => $max_filesize,
        '@formats' => $formats . ' zip',
        '@name' => $nice_name,
        '@location' => $weight > 0 ? t('above') : t('below'),
        '@type' => $field_or_group,
      )) . '</div></div>';
  }

  // Multigroup or field?
  if ($field_or_group == 'group') {
    $form[$machine_name .'_zip']['#weight'] = $weight;
    $form[$machine_name .'_zip'][$machine_name . '_button']['#submit'] = array('content_multigroup_add_more_submit');
    $form[$machine_name .'_zip'][$machine_name . '_button']['#ahah']['path'] = 'imagefield_zip/ahah-multigroup/' . $machine_node_type . '/' . $machine_name;
    $form[$machine_name .'_zip'][$machine_name . '_button']['#group_name'] = $machine_name;
  }
  else {
    $form[$machine_name .'_zip']['#weight'] = intval($form[$machine_name]['#weight']) + $weight;
    $form[$machine_name .'_zip'][$machine_name . '_button']['#submit'] = array('content_add_more_submit_proxy');
    $form[$machine_name .'_zip'][$machine_name . '_button']['#ahah']['path'] = 'imagefield_zip/ahah/' . $machine_node_type . '/' . $machine_name;
    $form[$machine_name .'_zip'][$machine_name . '_button']['#field_name'] = $machine_name;
    $form[$machine_name]['#prefix'] .= '<div id="'. $machine_name_css .'-items">';
    $form[$machine_name]['#suffix'] .= '</div>';
  }

  return TRUE;
}

/**
 * Get all fields that could use bulk uploading.
 *
 * @param $type
 *   content_types() array.
 */
function _imagefield_zip_fields(&$type) {
  $fields = array();

  foreach ($type['fields'] as $field_name => $field) {
    if ($field['widget']['module'] == 'imagefield' && $field['active'] && $field['multiple']) {
      $fields[$field_name] = $field;
    }
  }

  return $fields;
}

/**
 * Extracts the contents of a zip file.
 *
 * @param $filepath
 *   Location of zip file.
 * @param $formats
 *   String of file extensions to check against.
 */
function imagefield_zip_extract($zip_file, $formats) {
  $filepath = $zip_file->filepath;
  $extracted = array();
  // Exit if zip_open function does not exist.
  if (!function_exists('zip_open')) {
    watchdog('imagefield_zip', 'Required function zip_open was not available', array(), WATCHDOG_CRITICAL);
    return NULL;
  }

  // Open zip file.
  $z = zip_open($filepath);
  $max_filesize = parse_size(file_upload_max_size());

  // Exit if unable to open zip file.
  if (!is_resource($z)) {
    watchdog('imagefield_zip', 'Failed to unpack uploaded file %filepath. %error', array(
      '%filepath' => $filepath,
      '%error' => imagefield_zip_error($z),
    ), WATCHDOG_WARNING);
    return $extracted;
  }

  // Create directory if it doesn't exist.
  $dest = file_destination(file_directory_temp() .'/'. basename($filepath, '.zip'), FILE_EXISTS_RENAME);
  mkdir($dest, 0755);

  // Iterate over each file.
  while ($entry = zip_read($z)) {
    if (!zip_entry_open($z, $entry, 'r')) {
      watchdog('imagefield_zip', 'Failed to read an entry in the uploaded file %filepath. %error', array(
        '%filepath' => $filepath,
        '%error' => imagefield_zip_error($entry),
      ), WATCHDOG_WARNING);
      continue;
    }

    // Get the file's size and name.
    $filesize = zip_entry_filesize($entry);
    $entry_name = zip_entry_name($entry);

    // Make sure filesize is within limits.
    if (empty($filesize) || $filesize > $max_filesize) {
      watchdog('imagefield_zip', 'Zip file %filepath containing %entry is either empty or over the max file size: %size', array(
        '%filepath' => $filepath,
        '%entry' => $entry_name,
        '%size' => format_size($max_filesize),
      ), WATCHDOG_WARNING);
      continue;
    }

    // Create destination directory if it doesn't exist.
    $file_dest = $dest . '/' . $entry_name;
    $parent_dir = dirname($file_dest);
    if (!file_exists($parent_dir)) {
      imagefield_zip_mkdir_recursive($parent_dir);
    }

    // Create temp target file.
    $file_source = file_directory_temp();
    // On Windows, tempnam() requires an absolute path, so we use realpath().
    $file_source = tempnam(realpath($file_source), 'file');
    if (!$fp = fopen($file_source, 'wb')) {
      drupal_set_message(t('The file could not be created %name.', array('%name' => $file_source)), 'error');
      continue;
    }

    // Read/Write up to 1MB per step. Prevents excessive memory usage.
    while ($filesize > 0) {
      $readsize = min($filesize, 1048576);
      // Decrease the size of the remaining data to read.
      $filesize -= $readsize;

      // Get the data.
      $content = zip_entry_read($entry, $readsize);
      // Write the data (if any).
      if ($content !== FALSE) {
        fwrite($fp, $content);
      }
    }
    fclose($fp);

    // Move file and create file object.
    if (file_move($file_source, $file_dest)) {
      $file = new stdClass();
      $file->filepath = $file_source;
      $file->filename = $entry_name;
      $file->filemime = file_get_mimetype($file_source);
      $file->filesize = filesize($file_source);

      if (imagefield_zip_is_image($file, $formats)) {
        $extracted[] = $file;
      }
      else {
        imagefield_zip_delete_file($file);
      }
    }
    zip_entry_close($entry);
  }
  zip_close($z);
  // Free memory.
  if (isset($content)) {
    unset($content);
  }
  // Delete the zip file as we extracted and used everything we wanted from it.
  imagefield_zip_delete_file($zip_file);

  return $extracted;
}

/**
 * Delete a file from the file system and from the files table.
 *
 * @param $file
 *   file object
 */
function imagefield_zip_delete_file(&$file) {
  if (empty($file)) {
    watchdog('imagefield_zip', 'Attempted to delete a non-existent file. Failing', array(), WATCHDOG_NOTICE);
    return NULL;
  }
  if ($file->fid) {
    db_query("DELETE FROM {files} WHERE fid = %d", $file->fid);
  }
  return file_delete($file->filepath);
}

/**
 * Check that the zip file is valid.
 *
 * @param $file
 *   file object
 */
function imagefield_zip_is_valid_zip(&$file) {
  $errors = array();
  if (!function_exists('zip_open')) {
    return FALSE;
  }
  if (substr($file->filepath, -4) !== '.zip') {
    // Zip file must end in .zip
    return FALSE;
  }
  // See if we can open the zip file.
  $z = zip_open($file->filepath);
  if (!is_resource($z)) {
    return FALSE;
  }
  zip_close($z);
  return TRUE;
}

/**
 * Check that the file is an image.
 *
 * @param $file
 *   file object.
 * @param $formats
 *   String of file extensions to check against.
 */
function imagefield_zip_is_image(&$file, $formats) {
  if (empty($file->filepath)) {
    return FALSE;
  }

  $formats_array = explode(' ', $formats);
  $valid_file = FALSE;
  foreach ($formats_array as $ext) {
    $ext = '.' . $ext;
    $ext_len = strlen($ext) * -1;
    if (strcasecmp(substr($file->filepath, $ext_len), $ext) === 0) {
      // File ends in one of the valid formats.
      $valid_file = TRUE;
      break;
    }
  }
  if (!$valid_file) {
    return FALSE;
  }

  $info = image_get_info($file->filepath);
  if (!$info || empty($info['extension'])) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Report error from zip open function.
 *
 * @see http://php.net/manual/en/function.zip-open.php#75840
 *
 * @param $errno
 *   Error number
 */
function imagefield_zip_error($errno) {
  // using constant name as a string to make this function PHP4 compatible
  $zipFileFunctionsErrors = array(
    'ZIPARCHIVE::ER_MULTIDISK' => t('Multi-disk zip archives not supported.'),
    'ZIPARCHIVE::ER_RENAME' => t('Renaming temporary file failed.'),
    'ZIPARCHIVE::ER_CLOSE' => t('Closing zip archive failed'),
    'ZIPARCHIVE::ER_SEEK' => t('Seek error'),
    'ZIPARCHIVE::ER_READ' => t('Read error'),
    'ZIPARCHIVE::ER_WRITE' => t('Write error'),
    'ZIPARCHIVE::ER_CRC' => t('CRC error'),
    'ZIPARCHIVE::ER_ZIPCLOSED' => t('Containing zip archive was closed'),
    'ZIPARCHIVE::ER_NOENT' => t('No such file.'),
    'ZIPARCHIVE::ER_EXISTS' => t('File already exists'),
    'ZIPARCHIVE::ER_OPEN' => t('Can\'t open file'),
    'ZIPARCHIVE::ER_TMPOPEN' => t('Failure to create temporary file.'),
    'ZIPARCHIVE::ER_ZLIB' => t('Zlib error'),
    'ZIPARCHIVE::ER_MEMORY' => t('Memory allocation failure'),
    'ZIPARCHIVE::ER_CHANGED' => t('Entry has been changed'),
    'ZIPARCHIVE::ER_COMPNOTSUPP' => t('Compression method not supported.'),
    'ZIPARCHIVE::ER_EOF' => t('Premature EOF'),
    'ZIPARCHIVE::ER_INVAL' => t('Invalid argument'),
    'ZIPARCHIVE::ER_NOZIP' => t('Not a zip archive'),
    'ZIPARCHIVE::ER_INTERNAL' => t('Internal error'),
    'ZIPARCHIVE::ER_INCONS' => t('Zip archive inconsistent'),
    'ZIPARCHIVE::ER_REMOVE' => t('Can\'t remove file'),
    'ZIPARCHIVE::ER_DELETED' => t('Entry has been deleted'),
  );
  $errmsg = 'unknown';
  foreach ($zipFileFunctionsErrors as $constName => $errorMessage) {
    if (defined($constName) && constant($constName) === $errno) {
      return 'Zip File Function error: ' . $errorMessage;
    }
  }
  return 'Zip File Function error: unknown ' . $errno;
}

/**
 * Recursive make directory, returns TRUE if exists or made.
 *
 * @param string $pathname
 *   The directory path.
 * @return boolean
 *   returns TRUE if exists or made or FALSE on failure.
 */
function imagefield_zip_mkdir_recursive($pathname, $mode = 0777) {
  if (is_dir($pathname)) {
    return is_dir($pathname);
  }
  if (!is_dir(dirname($pathname))) {
    imagefield_zip_mkdir_recursive(dirname($pathname), $mode);
  }
  return @mkdir($pathname, $mode);
}

/**
 * Saves a file upload to a new location.
 *
 * The source file is validated as a proper upload and handled as such.
 * The file will be added to the files table as a temporary file. Temporary
 * files are periodically cleaned. To make the file permanent file call
 * file_set_status() to change its status.
 *
 * @param $source
 *   A string specifying the name of the upload field to save.
 * @param $validators
 *   (optional) An associative array of callback functions used to validate the
 *   file. The keys are function names and the values arrays of callback
 *   parameters which will be passed in after the file object. The
 *   functions should return an array of error messages; an empty array
 *   indicates that the file passed validation. The functions will be called in
 *   the order specified.
 * @param $dest
 *   A string containing the directory $source should be copied to. If this is
 *   not provided or is not writable, the temporary directory will be used.
 * @param $replace
 *   Replace behavior when the destination file already exists:
 *   - FILE_EXISTS_REPLACE: Replace the existing file.
 *   - FILE_EXISTS_RENAME: Append _{incrementing number} until the filename
 *     is unique.
 *   - FILE_EXISTS_ERROR: Do nothing and return FALSE.
 * @param $file_array
 *   Emulate $_FILES array.
 *
 * @return
 *   An object containing the file information, or 0 in the event of an error.
 */
function imagefield_zip_file_save_upload($source, $validators = array(), $dest = FALSE, $replace = FILE_EXISTS_RENAME, $file_array = array()) {
  global $user;

  // Add in our check of the the file name length.
  $validators['file_validate_name_length'] = array();

  // Return 0 if the file is not there.
  if (   empty($file_array)
      || !isset($file_array['files']['name'][$source])
      || !is_uploaded_file($file_array['files']['tmp_name'][$source])
        ) {
    return 0;
  }

  // Check for file upload errors and return FALSE if a
  // lower level system error occurred.
  switch ($file_array['files']['error'][$source]) {
    // @see http://php.net/manual/en/features.file-upload.errors.php
    case UPLOAD_ERR_OK:
      break;

    case UPLOAD_ERR_INI_SIZE:
    case UPLOAD_ERR_FORM_SIZE:
      drupal_set_message(t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size()))), 'error');
      return 0;

    case UPLOAD_ERR_PARTIAL:
    case UPLOAD_ERR_NO_FILE:
      drupal_set_message(t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source)), 'error');
      return 0;

      // Unknown error
    default:
      drupal_set_message(t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source)), 'error');
      return 0;
  }

  // Build the list of non-munged extensions.
  // @todo: this should not be here. we need to figure out the right place.
  $extensions = '';
  foreach ($user->roles as $rid => $name) {
    $extensions .= ' '. variable_get("upload_extensions_$rid",
    variable_get('upload_extensions_default', 'jpg jpeg gif png txt html doc xls pdf ppt pps odt ods odp'));
  }

  // Begin building file object.
  $file = new stdClass();
  $file->filename = file_munge_filename(trim(basename($file_array['files']['name'][$source]), '.'), $extensions);
  $file->filepath = $file_array['files']['tmp_name'][$source];
  $file->filemime = file_get_mimetype($file->filename);

  // If the destination is not provided, or is not writable, then use the
  // temporary directory.
  if (empty($dest) || file_check_path($dest) === FALSE) {
    $dest = file_directory_temp();
  }

  $file->source = $source;
  $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);
  $file->filesize = $file_array['files']['size'][$source];

  // Call the validation functions.
  $errors = array();
  foreach ($validators as $function => $args) {
    array_unshift($args, $file);
    // Make sure $file is passed around by reference.
    $args[0] = &$file;
    $errors = array_merge($errors, call_user_func_array($function, $args));
  }

  // Rename potentially executable files, to help prevent exploits.
  if (preg_match('/\.(php|pl|py|cgi|asp|js)$/i', $file->filename) && (substr($file->filename, -4) != '.txt')) {
    $file->filemime = 'text/plain';
    $file->filepath .= '.txt';
    $file->filename .= '.txt';
    // As the file may be named example.php.txt, we need to munge again to
    // convert to example.php_.txt, then create the correct destination.
    $file->filename = file_munge_filename($file->filename, $extensions);
    $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);
  }


  // Check for validation errors.
  if (!empty($errors)) {
    $message = t('The selected file %name could not be uploaded.', array('%name' => $file->filename));
    if (count($errors) > 1) {
      $message .= '<ul><li>'. implode('</li><li>', $errors) .'</li></ul>';
    }
    else {
      $message .= ' '. array_pop($errors);
    }
    form_set_error($source, $message);
    return 0;
  }

  // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary directory.
  // This overcomes open_basedir restrictions for future file operations.
  $file->filepath = $file->destination;
  if (!move_uploaded_file($file_array['files']['tmp_name'][$source], $file->filepath)) {
    form_set_error($source, t('File upload error. Could not move uploaded file.'));
    watchdog('file', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));
    return 0;
  }

  // If we made it this far it's safe to record this file in the database.
  $file->uid = $user->uid;
  $file->status = FILE_STATUS_TEMPORARY;
  $file->timestamp = time();
  drupal_write_record('files', $file);

  return $file;
}

/**
 * Extract each file uploaded to make it look like a single file.
 *
 * @param $field_name
 *   A string specifying the name of the upload field.
 *
 * @return
 *   An array containing an emulation of a single file in the $_FILES array.
 */
function imagefield_zip_files_array_extractor($field_name) {
  $files_array = array();
  if (!is_array($_FILES['files']['name'][$field_name]) && $_FILES['files']['name'][$field_name] != 'array') {
    $files_array[] = $_FILES;
  }
  else {
    foreach ($_FILES['files'] as $key_name => $values) {
      foreach ($values as $key_field_name => $info) {
        if ($key_field_name != $field_name) {
          continue;
        }

        if (is_array($info)) {
          foreach ($info as $delta => $value) {
            $files_array[$delta]['files'][$key_name][$key_field_name] = $value;
            if ($key_name == 'orig_name' && empty($files_array[$delta]['files']['name'][$key_field_name])) {
              $files_array[$delta]['files']['name'][$key_field_name] = $value;
            }
          }
        }
      }
    }
  }
  // Remove empty files.
  foreach ($files_array as $delta => $file_array) {
    if ($file_array['files']['error'][$field_name] == UPLOAD_ERR_NO_FILE) {
      unset($files_array[$delta]);
    }
  }
  return $files_array;
}

/**
 * See if the browser is IE.
 *
 * @return
 *   TRUE if the browser is IE; false if the browser is not IE.
 */
function imagefield_zip_is_ie() {
  $is_ie = FALSE;
  if (isset($_SERVER['HTTP_USER_AGENT'])) {
    // Strings for testing found via
    // http://chrisschuld.com/projects/browser-php-detecting-a-users-browser-from-php/
    // Test for v1 - v1.5 IE
    // Test for versions > 1.5
    // Test for Pocket IE
    if (   stristr($_SERVER['HTTP_USER_AGENT'], 'microsoft internet explorer')
        || stristr($_SERVER['HTTP_USER_AGENT'], 'msie')
        || stristr($_SERVER['HTTP_USER_AGENT'], 'mspie')
        ) {
      $is_ie = TRUE;
    }
  }
  return $is_ie;
}
